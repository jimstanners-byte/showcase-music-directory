{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/src/components/ListingsMap.tsx"],"sourcesContent":["'use client';\n\nimport Link from 'next/link';\nimport { useMemo, useCallback, useEffect, useRef, useState } from \"react\";\nimport Map, { Marker, Popup, NavigationControl, MapRef } from \"react-map-gl/maplibre\";\nimport Supercluster from \"supercluster\";\nimport { Listing, ListingPublic } from \"@/types/database\";\nimport { MapPin } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { FavouriteButton } from \"@/components/FavouriteButton\";\nimport { cn } from \"@/lib/utils\";\nimport \"maplibre-gl/dist/maplibre-gl.css\";\n\n// Free map style - using Carto's positron style for cleaner look\nconst MAP_STYLE = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\";\n\nexport interface MapBounds {\n  north: number;\n  south: number;\n  east: number;\n  west: number;\n}\n\ninterface ListingsMapProps {\n  listings: (Listing | ListingPublic)[];\n  selectedListing?: Listing | ListingPublic | null;\n  onSelectListing?: (listing: Listing | ListingPublic | null) => void;\n  highlightedListingId?: string | null;\n  onBoundsChange?: (bounds: MapBounds, zoom: number) => void;\n  initialState?: {\n    bounds: MapBounds;\n    zoom: number;\n  } | null;\n  resetTrigger?: number; // Increment to force map to re-fit to bounds\n}\n\n// Type for our cluster points\ninterface ListingProperties {\n  id: string;\n  listing: Listing | ListingPublic;\n}\n\ntype ListingPoint = GeoJSON.Feature<GeoJSON.Point, ListingProperties>;\n\nexport function ListingsMap({\n  listings,\n  selectedListing,\n  onSelectListing,\n  highlightedListingId,\n  onBoundsChange,\n  initialState,\n  resetTrigger,\n}: ListingsMapProps) {\n  const mapRef = useRef<MapRef>(null);\n  const [zoom, setZoom] = useState(3);\n  const [bounds, setBounds] = useState<[number, number, number, number] | null>(null);\n  const [internalSelectedListing, setInternalSelectedListing] = useState<Listing | ListingPublic | null>(null);\n\n  // Use internal state if no external control\n  const actualSelectedListing = selectedListing !== undefined ? selectedListing : internalSelectedListing;\n  const handleSelectListing = onSelectListing || setInternalSelectedListing;\n\n  // Smart auto-pan: only pan if popup would be clipped, with smooth animation\n  const ensurePopupVisible = useCallback((lng: number, lat: number) => {\n    if (!mapRef.current) return;\n\n    const map = mapRef.current;\n    const point = map.project([lng, lat]);\n    const container = map.getContainer();\n    const width = container.offsetWidth;\n    const height = container.offsetHeight;\n\n    // Popup dimensions (approximate) + padding\n    const popupHeight = 160; // Approximate popup height including offset\n    const popupWidth = 100; // Half of popup width (centered on point)\n    const padding = 20; // Edge padding\n\n    let panX = 0;\n    let panY = 0;\n\n    // Check if popup would be clipped at top\n    if (point.y - popupHeight - padding < 0) {\n      panY = point.y - popupHeight - padding;\n    }\n\n    // Check if popup would be clipped at bottom (unlikely with bottom anchor, but check anyway)\n    if (point.y + padding > height) {\n      panY = point.y + padding - height;\n    }\n\n    // Check left edge\n    if (point.x - popupWidth - padding < 0) {\n      panX = point.x - popupWidth - padding;\n    }\n\n    // Check right edge\n    if (point.x + popupWidth + padding > width) {\n      panX = point.x + popupWidth + padding - width;\n    }\n\n    // Only pan if needed\n    if (panX !== 0 || panY !== 0) {\n      map.panBy([panX, panY], { duration: 300 });\n    }\n  }, []);\n\n  // Filter listings with valid coordinates\n  const mappableListings = useMemo(\n    () => listings.filter((l) => l.latitude !== null && l.longitude !== null),\n    [listings],\n  );\n\n  // Create supercluster instance - smaller radius for more granular clusters\n  const supercluster = useMemo(() => {\n    const cluster = new Supercluster<ListingProperties>({\n      radius: 40, // Reduced from 60 for more granular clusters\n      maxZoom: 16,\n      minZoom: 0,\n    });\n\n    const points: ListingPoint[] = mappableListings.map((listing) => ({\n      type: \"Feature\",\n      properties: {\n        id: listing.id,\n        listing,\n      },\n      geometry: {\n        type: \"Point\",\n        coordinates: [listing.longitude!, listing.latitude!],\n      },\n    }));\n\n    cluster.load(points);\n    return cluster;\n  }, [mappableListings]);\n\n  // Get clusters for current viewport\n  const clusters = useMemo(() => {\n    if (!bounds) return [];\n    return supercluster.getClusters(bounds, Math.floor(zoom));\n  }, [supercluster, bounds, zoom]);\n\n  // Find which cluster contains the highlighted listing (if any)\n  const highlightedClusterId = useMemo(() => {\n    if (!highlightedListingId || !bounds) return null;\n\n    // Check if the highlighted listing is visible as an individual marker\n    const isIndividualMarker = clusters.some((cluster) => {\n      const props = cluster.properties as any;\n      return !props.cluster && props.listing?.id === highlightedListingId;\n    });\n\n    if (isIndividualMarker) return null; // No need to highlight cluster\n\n    // Find which cluster contains this listing\n    for (const cluster of clusters) {\n      const props = cluster.properties as any;\n      if (props.cluster) {\n        const leaves = supercluster.getLeaves(props.cluster_id, Infinity);\n        const containsListing = leaves.some((leaf) => leaf.properties.id === highlightedListingId);\n        if (containsListing) {\n          return props.cluster_id;\n        }\n      }\n    }\n    return null;\n  }, [highlightedListingId, clusters, supercluster, bounds]);\n\n  // Calculate initial bounds\n  const initialBounds = useMemo(() => {\n    if (mappableListings.length === 0) return null;\n\n    const lats = mappableListings.map((l) => l.latitude!);\n    const lngs = mappableListings.map((l) => l.longitude!);\n\n    return {\n      minLat: Math.min(...lats),\n      maxLat: Math.max(...lats),\n      minLng: Math.min(...lngs),\n      maxLng: Math.max(...lngs),\n    };\n  }, [mappableListings]);\n\n  // Fit to bounds when listings change (but not if we have saved state to restore)\n  const hasRestoredState = useRef(false);\n  const prevBoundsRef = useRef<typeof initialBounds>(null);\n  const prevResetTrigger = useRef<number | undefined>(undefined);\n\n  useEffect(() => {\n    if (!mapRef.current || !initialBounds) return;\n\n    // Check if this is a forced reset (resetTrigger changed)\n    const isForceReset = resetTrigger !== undefined && resetTrigger !== prevResetTrigger.current;\n    prevResetTrigger.current = resetTrigger;\n\n    // If force reset, clear the restored state and fit to bounds\n    if (isForceReset) {\n      hasRestoredState.current = false;\n      prevBoundsRef.current = initialBounds;\n      const map = mapRef.current;\n      map.fitBounds(\n        [\n          [initialBounds.minLng, initialBounds.minLat],\n          [initialBounds.maxLng, initialBounds.maxLat],\n        ],\n        { padding: 50, maxZoom: 12, duration: 500 },\n      );\n      return;\n    }\n\n    // If we have saved state to restore, mark as restored and skip (onMapLoad handles it)\n    if (initialState) {\n      hasRestoredState.current = true;\n      prevBoundsRef.current = initialBounds;\n      return;\n    }\n\n    // Check if bounds actually changed (different listings)\n    const boundsChanged =\n      !prevBoundsRef.current ||\n      prevBoundsRef.current.minLat !== initialBounds.minLat ||\n      prevBoundsRef.current.maxLat !== initialBounds.maxLat ||\n      prevBoundsRef.current.minLng !== initialBounds.minLng ||\n      prevBoundsRef.current.maxLng !== initialBounds.maxLng;\n\n    prevBoundsRef.current = initialBounds;\n\n    // If bounds changed (filter change), fit to new bounds\n    // If bounds same and we restored, skip (user is browsing same data)\n    if (!boundsChanged && hasRestoredState.current) {\n      return;\n    }\n\n    // Reset restored flag when bounds change\n    if (boundsChanged) {\n      hasRestoredState.current = false;\n    }\n\n    const map = mapRef.current;\n    map.fitBounds(\n      [\n        [initialBounds.minLng, initialBounds.minLat],\n        [initialBounds.maxLng, initialBounds.maxLat],\n      ],\n      { padding: 50, maxZoom: 12, duration: 500 },\n    );\n  }, [initialBounds, initialState, resetTrigger]);\n\n  // Handle map load\n  const onMapLoad = useCallback(() => {\n    if (!mapRef.current) return;\n\n    const map = mapRef.current;\n\n    // If we have saved state to restore, use it\n    if (initialState) {\n      map.fitBounds(\n        [\n          [initialState.bounds.west, initialState.bounds.south],\n          [initialState.bounds.east, initialState.bounds.north],\n        ],\n        { padding: 0, duration: 0 },\n      );\n    } else if (initialBounds) {\n      // Otherwise fit to all listings\n      map.fitBounds(\n        [\n          [initialBounds.minLng, initialBounds.minLat],\n          [initialBounds.maxLng, initialBounds.maxLat],\n        ],\n        { padding: 50, maxZoom: 12, duration: 0 },\n      );\n    }\n\n    // Set initial bounds state\n    const mapBounds = map.getBounds();\n    if (mapBounds) {\n      const newBounds: [number, number, number, number] = [\n        mapBounds.getWest(),\n        mapBounds.getSouth(),\n        mapBounds.getEast(),\n        mapBounds.getNorth(),\n      ];\n      setBounds(newBounds);\n      setZoom(map.getZoom());\n\n      // Notify parent\n      onBoundsChange?.(\n        {\n          west: newBounds[0],\n          south: newBounds[1],\n          east: newBounds[2],\n          north: newBounds[3],\n        },\n        map.getZoom(),\n      );\n    }\n  }, [initialBounds, initialState, onBoundsChange]);\n\n  // Handle map move\n  const onMoveEnd = useCallback(() => {\n    if (!mapRef.current) return;\n\n    const map = mapRef.current;\n    const mapBounds = map.getBounds();\n    const newZoom = map.getZoom();\n\n    if (mapBounds) {\n      const newBounds: [number, number, number, number] = [\n        mapBounds.getWest(),\n        mapBounds.getSouth(),\n        mapBounds.getEast(),\n        mapBounds.getNorth(),\n      ];\n      setBounds(newBounds);\n      setZoom(newZoom);\n\n      // Notify parent of bounds change for list filtering and state persistence\n      onBoundsChange?.(\n        {\n          west: newBounds[0],\n          south: newBounds[1],\n          east: newBounds[2],\n          north: newBounds[3],\n        },\n        newZoom,\n      );\n    }\n  }, [onBoundsChange]);\n\n  // Handle cluster click - smart zoom based on cluster size\n  const handleClusterClick = useCallback(\n    (clusterId: number, clusterLng: number, clusterLat: number) => {\n      if (!mapRef.current) return;\n\n      const leaves = supercluster.getLeaves(clusterId, Infinity);\n      if (leaves.length === 0) return;\n\n      // For large clusters (100+), use expansion zoom (one level at a time)\n      if (leaves.length > 100) {\n        const expansionZoom = supercluster.getClusterExpansionZoom(clusterId);\n        mapRef.current.flyTo({\n          center: [clusterLng, clusterLat],\n          zoom: Math.min(expansionZoom + 1, 14),\n          duration: 500,\n        });\n        return;\n      }\n\n      // For smaller clusters, fit bounds to show all listings\n      const lngs = leaves.map((l) => l.geometry.coordinates[0]);\n      const lats = leaves.map((l) => l.geometry.coordinates[1]);\n\n      const minLng = Math.min(...lngs);\n      const maxLng = Math.max(...lngs);\n      const minLat = Math.min(...lats);\n      const maxLat = Math.max(...lats);\n\n      const lngPad = Math.max((maxLng - minLng) * 0.15, 0.01);\n      const latPad = Math.max((maxLat - minLat) * 0.15, 0.01);\n\n      mapRef.current.fitBounds(\n        [\n          [minLng - lngPad, minLat - latPad],\n          [maxLng + lngPad, maxLat + latPad],\n        ],\n        { padding: 50, maxZoom: 16, duration: 500 },\n      );\n    },\n    [supercluster],\n  );\n\n  // Format count for display\n  const formatCount = (count: number): string => {\n    if (count >= 1000) return `${(count / 1000).toFixed(1)}k`;\n    return count.toString();\n  };\n\n  // Empty state\n  if (mappableListings.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full bg-card border rounded-lg p-8\">\n        <MapPin className=\"h-12 w-12 text-muted-foreground mb-4\" />\n        <p className=\"text-lg font-medium text-foreground\">No locations to display</p>\n        <p className=\"text-sm text-muted-foreground mt-1\">Locations will appear once geocoded</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"h-full rounded-lg overflow-hidden border bg-card\">\n      <Map\n        ref={mapRef}\n        initialViewState={{\n          latitude: initialBounds ? (initialBounds.minLat + initialBounds.maxLat) / 2 : 50,\n          longitude: initialBounds ? (initialBounds.minLng + initialBounds.maxLng) / 2 : 0,\n          zoom: 3,\n        }}\n        mapStyle={MAP_STYLE}\n        style={{ width: \"100%\", height: \"100%\" }}\n        onLoad={onMapLoad}\n        onMoveEnd={onMoveEnd}\n        onClick={() => handleSelectListing(null)}\n      >\n        <NavigationControl position=\"top-right\" />\n\n        {/* Render clusters and individual markers */}\n        {clusters.map((cluster) => {\n          const [longitude, latitude] = cluster.geometry.coordinates;\n          const properties = cluster.properties as any;\n\n          // It's a cluster\n          if (properties.cluster) {\n            const count = properties.point_count;\n            const isHighlighted = properties.cluster_id === highlightedClusterId;\n            const baseSize = Math.min(28 + Math.sqrt(count) * 2, 50);\n            const size = isHighlighted ? baseSize * 1.3 : baseSize;\n\n            return (\n              <Marker\n                key={`cluster-${properties.cluster_id}`}\n                longitude={longitude}\n                latitude={latitude}\n                anchor=\"center\"\n                onClick={(e) => {\n                  e.originalEvent.stopPropagation();\n                  handleClusterClick(properties.cluster_id, longitude, latitude);\n                }}\n              >\n                <div\n                  className={cn(\n                    \"flex items-center justify-center rounded-full cursor-pointer transition-all duration-150\",\n                    isHighlighted ? \"scale-110 ring-4 ring-accent/50\" : \"hover:scale-110\",\n                  )}\n                  style={{\n                    width: size,\n                    height: size,\n                    backgroundColor: isHighlighted ? \"hsl(var(--accent))\" : \"hsl(var(--primary))\",\n                    color: \"hsl(var(--primary-foreground))\",\n                    fontSize: Math.max(11, baseSize * 0.32),\n                    fontWeight: 600,\n                    boxShadow: isHighlighted ? \"0 4px 12px rgba(0,0,0,0.4)\" : \"0 2px 8px rgba(0,0,0,0.3)\",\n                    border: isHighlighted ? \"3px solid white\" : \"2px solid white\",\n                  }}\n                >\n                  {formatCount(count)}\n                </div>\n              </Marker>\n            );\n          }\n\n          // It's an individual listing\n          const listing = properties.listing as Listing;\n          const isHighlighted = highlightedListingId === listing.id;\n\n          // Handler for both mouse and touch interactions\n          const handleMarkerInteraction = (e: React.MouseEvent | React.TouchEvent) => {\n            e.stopPropagation();\n            handleSelectListing(listing);\n            // Smart pan to ensure popup is visible\n            if (listing.longitude && listing.latitude) {\n              setTimeout(() => ensurePopupVisible(listing.longitude!, listing.latitude!), 50);\n            }\n          };\n\n          return (\n            <Marker key={listing.id} longitude={longitude} latitude={latitude} anchor=\"bottom\">\n              <div\n                className={`cursor-pointer transition-transform duration-150 ${\n                  isHighlighted ? \"scale-150 z-10\" : \"hover:scale-125\"\n                }`}\n                onMouseEnter={handleMarkerInteraction}\n                onClick={handleMarkerInteraction}\n                onTouchStart={handleMarkerInteraction}\n              >\n                <MapPin\n                  className=\"h-7 w-7 drop-shadow-lg\"\n                  style={{\n                    fill: isHighlighted ? \"hsl(var(--accent))\" : \"hsl(var(--primary))\",\n                    stroke: \"white\",\n                    strokeWidth: 1.5,\n                  }}\n                />\n              </div>\n            </Marker>\n          );\n        })}\n\n        {/* Popup for selected listing */}\n        {actualSelectedListing && actualSelectedListing.latitude && actualSelectedListing.longitude && (\n          <Popup\n            longitude={actualSelectedListing.longitude}\n            latitude={actualSelectedListing.latitude}\n            anchor=\"bottom\"\n            onClose={() => handleSelectListing(null)}\n            closeOnClick={false}\n            offset={25}\n            maxWidth=\"200px\"\n          >\n            <div className=\"p-2.5 min-w-[160px]\">\n              <div className=\"flex items-start justify-between gap-1 mb-1\">\n                <h3 className=\"font-semibold leading-tight line-clamp-2\">{actualSelectedListing.name}</h3>\n                <FavouriteButton listingId={actualSelectedListing.id} size=\"sm\" className=\"h-5 w-5 p-0 shrink-0\" />\n              </div>\n\n              {actualSelectedListing.town_city && (\n                <p className=\"text-muted-foreground mb-2\">\n                  {actualSelectedListing.town_city}, {actualSelectedListing.country}\n                </p>\n              )}\n\n              <Button asChild size=\"sm\" className=\"w-full h-7 text-xs\">\n                <Link href={`/listing/${actualSelectedListing.slug}`}>View Details</Link>\n              </Button>\n            </div>\n          </Popup>\n        )}\n      </Map>\n    </div>\n  );\n}\n\n// Default export for backward compatibility with lazy loading\nexport default ListingsMap;\n"],"names":[],"mappings":"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","debugId":null}}]
}