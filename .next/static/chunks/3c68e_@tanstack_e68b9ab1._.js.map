{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/query-core/src/queryObserver.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error('experimental_prefetchInRender feature flag is not enabled'),\n      )\n    }\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult()\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key as keyof QueryObserverResult)\n        onPropTracked?.(key as keyof QueryObserverResult)\n        return Reflect.get(target, key)\n      },\n    })\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Per default, use query data\n    data = newState.data as unknown as TData\n    let skipSelect = false\n\n    // use placeholderData if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n        // we have to skip select when reading this memoization\n        // because prevResult.data is already \"selected\"\n        skipSelect = true\n      } else {\n        // compute placeholderData\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    // Select data if needed\n    // this also runs placeholderData through the select function\n    if (options.select && data !== undefined && !skipSelect) {\n      // Memoize select result\n      if (\n        prevResult &&\n        data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(data as any)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (nextResult.status === 'error') {\n          thenable.reject(nextResult.error)\n        } else if (nextResult.data !== undefined) {\n          thenable.resolve(nextResult.data)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (\n            nextResult.status === 'error' ||\n            nextResult.data !== prevThenable.value\n          ) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (\n            nextResult.status !== 'error' ||\n            nextResult.error !== prevThenable.reason\n          ) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    this.#notify({ listeners: shouldNotifyListeners() })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: { listeners: boolean }): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (\n    resolveEnabled(options.enabled, query) !== false &&\n    resolveStaleTime(options.staleTime, query) !== 'static'\n  ) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/query-core/src/mutationObserver.ts"],"sourcesContent":["import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<TData, TError, TVariables, TContext> =\n    undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TContext>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    } else if (this.#currentMutation?.state.status === 'pending') {\n      this.#currentMutation.setOptions(this.options)\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TContext>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TContext>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const context = this.#currentResult.context\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context!)\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context)\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(action.error, variables, context)\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/react-query/src/QueryErrorResetBoundary.tsx"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n"],"names":[],"mappings":";;;;;;;AACA,YAAY,WAAW;AAkDnB;;;;AArCJ,SAAS,cAA4C;IACnD,IAAI,UAAU;IACd,OAAO;QACL,YAAY,MAAM;YAChB,UAAU;QACZ;QACA,OAAO,MAAM;YACX,UAAU;QACZ;QACA,SAAS,MAAM;YACb,OAAO;QACT;IACF;AACF;AAEA,IAAM,iCAAuC,kMAAA,CAAc,YAAY,CAAC;AAIjE,IAAM,6BAA6B,IAClC,+LAAA,CAAW,8BAA8B;AAY1C,IAAM,0BAA0B;QAAC,EACtC,QAAA,EACF,KAAoC;IAClC,MAAM,CAAC,KAAK,CAAA,GAAU,6LAAA;4CAAS,IAAM,YAAY,CAAC;;IAClD,OACE,aAAA,GAAA,IAAA,iMAAA,EAAC,+BAA+B,QAAA,EAA/B;QAAwC;QACtC,UAAA,OAAO,aAAa,aAAa,SAAS,KAAK,IAAI;IAAA,CACtD;AAEJ","debugId":null}},
    {"offset": {"line": 666, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/react-query/src/errorBoundaryUtils.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (\n    options.suspense ||\n    options.throwOnError ||\n    options.experimental_prefetchInRender\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n  suspense: boolean | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    ((suspense && result.data === undefined) ||\n      shouldThrowError(throwOnError, [result.error, query]))\n  )\n}\n"],"names":[],"mappings":";;;;;;;;;AACA,YAAY,WAAW;AACvB,SAAS,wBAAwB;;;;AAU1B,IAAM,kCAAkC,CAO7C,SAOA,uBACG;IACH,IACE,QAAQ,QAAA,IACR,QAAQ,YAAA,IACR,QAAQ,6BAAA,EACR;QAEA,IAAI,CAAC,mBAAmB,OAAA,CAAQ,GAAG;YACjC,QAAQ,YAAA,GAAe;QACzB;IACF;AACF;AAEO,IAAM,6BAA6B,CACxC,uBACG;IACG,8LAAA;gDAAU,MAAM;YACpB,mBAAmB,UAAA,CAAW;QAChC;+CAAG;QAAC,kBAAkB;KAAC;AACzB;AAEO,IAAM,cAAc;QAMzB,EACA,MAAA,EACA,kBAAA,EACA,YAAA,EACA,KAAA,EACA,QAAA,EACF,KAMM;IACJ,OACE,OAAO,OAAA,IACP,CAAC,mBAAmB,OAAA,CAAQ,KAC5B,CAAC,OAAO,UAAA,IACR,SAAA,CACE,YAAY,OAAO,IAAA,KAAS,KAAA,SAC5B,kNAAA,EAAiB,cAAc;QAAC,OAAO,KAAA;QAAO,KAAK;KAAC,CAAA;AAE1D","debugId":null}},
    {"offset": {"line": 709, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/react-query/src/IsRestoringProvider.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n"],"names":[],"mappings":";;;;;;;AACA,YAAY,WAAW;;;AAEvB,IAAM,qBAA2B,kMAAA,CAAc,KAAK;AAE7C,IAAM,iBAAiB,IAAY,+LAAA,CAAW,kBAAkB;AAChE,IAAM,sBAAsB,mBAAmB,QAAA","debugId":null}},
    {"offset": {"line": 728, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/react-query/src/suspense.ts"],"sourcesContent":["import type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n\n    const clamp = (value: number | 'static' | undefined) =>\n      value === 'static' ? value : Math.max(value ?? 1000, 1000)\n\n    const originalStaleTime = defaultedOptions.staleTime\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => clamp(originalStaleTime(...args))\n        : clamp(originalStaleTime)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n"],"names":[],"mappings":";;;;;;;;;;;;;AAUO,IAAM,sBAAsB,CAMjC,QACA,QACG,MAAM,KAAA,CAAM,IAAA,KAAS,KAAA;AAEnB,IAAM,uBAAuB,CAClC,qBACG;IACH,IAAI,iBAAiB,QAAA,EAAU;QAI7B,MAAM,QAAQ,CAAC,QACb,UAAU,WAAW,QAAQ,KAAK,GAAA,sCAAI,QAAS,KAAM,GAAI;QAE3D,MAAM,oBAAoB,iBAAiB,SAAA;QAC3C,iBAAiB,SAAA,GACf,OAAO,sBAAsB,aACzB;;gBAAI;;mBAAS,MAAM,kBAAkB,GAAG,IAAI,CAAC;YAC7C,MAAM,iBAAiB;QAE7B,IAAI,OAAO,iBAAiB,MAAA,KAAW,UAAU;YAC/C,iBAAiB,MAAA,GAAS,KAAK,GAAA,CAAI,iBAAiB,MAAA,EAAQ,GAAI;QAClE;IACF;AACF;AAEO,IAAM,YAAY,CACvB,QACA,cACG,OAAO,SAAA,IAAa,OAAO,UAAA,IAAc,CAAC;AAExC,IAAM,gBAAgB,CAC3B,kBAGA,8EACG,iBAAkB,QAAA,KAAY,OAAO,SAAA;AAEnC,IAAM,kBAAkB,CAO7B,kBAOA,UACA,qBAEA,SAAS,eAAA,CAAgB,gBAAgB,EAAE,KAAA,CAAM,MAAM;QACrD,mBAAmB,UAAA,CAAW;IAChC,CAAC","debugId":null}},
    {"offset": {"line": 768, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/react-query/src/useBaseQuery.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport { isServer, noop, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const client = useQueryClient(queryClient)\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`,\n      )\n    }\n  }\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions)\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n      suspense: defaultedOptions.suspense,\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n"],"names":[],"mappings":";;;;AA2CM,QAAQ,IAAI,aAAa;;AA1C/B,YAAY,WAAW;;AAEvB,SAAS,UAAU,MAAM,qBAAqB;AAC9C,SAAS,sBAAsB;AAC/B,SAAS,kCAAkC;AAC3C;AAKA,SAAS,sBAAsB;AAC/B;;;;;;;;;AAcO,SAAS,aAOd,OAAA,EAOA,QAAA,EACA,WAAA,EACoC;QAclC,4JAuFA;IApGF,wCAA2C;QACzC,IAAI,OAAO,YAAY,YAAY,MAAM,OAAA,CAAQ,OAAO,GAAG;YACzD,MAAM,IAAI,MACR;QAEJ;IACF;IAEA,MAAM,kBAAc,+NAAA,CAAe;IACnC,MAAM,yBAAqB,+OAAA,CAA2B;IACtD,MAAM,aAAS,+NAAA,EAAe,WAAW;IACzC,MAAM,mBAAmB,OAAO,mBAAA,CAAoB,OAAO;gDAElD,iBAAA,CAAkB,EAAE,OAAA,uKAAiB,yBAAA,oMAC5C;IAGF,IAAI,QAAQ,IAAI,aAAa,WAAc;QACzC,IAAI,CAAC,iBAAiB,OAAA,EAAS;YAC7B,QAAQ,KAAA,CACN,IAA8B,OAA1B,iBAAiB,SAAS,EAAA;QAElC;IACF;IAGA,iBAAiB,kBAAA,GAAqB,cAClC,gBACA;IAEJ,IAAA,0NAAA,EAAqB,gBAAgB;IACrC,IAAA,+OAAA,EAAgC,kBAAkB,kBAAkB;IAEpE,IAAA,0OAAA,EAA2B,kBAAkB;IAG7C,MAAM,kBAAkB,CAAC,OACtB,aAAA,CAAc,EACd,GAAA,CAAI,iBAAiB,SAAS;IAEjC,MAAM,CAAC,QAAQ,CAAA,GAAU,6LAAA;iCACvB,IACE,IAAI,SACF,QACA;;IAKN,MAAM,SAAS,SAAS,mBAAA,CAAoB,gBAAgB;IAE5D,MAAM,kBAAkB,CAAC,eAAe,QAAQ,UAAA,KAAe;IACzD,yMAAA,CACE,gMAAA;yDACJ,CAAC,kBAAkB;YACjB,MAAM,cAAc,kBAChB,SAAS,SAAA,CAAU,uNAAA,CAAc,UAAA,CAAW,aAAa,CAAC,IAC1D,sMAAA;YAIJ,SAAS,YAAA,CAAa;YAEtB,OAAO;QACT;wDACA;QAAC;QAAU,eAAe;KAAA;6CAE5B,IAAM,SAAS,gBAAA,CAAiB;;6CAChC,IAAM,SAAS,gBAAA,CAAiB;;IAG5B,8LAAA;kCAAU,MAAM;YACpB,SAAS,UAAA,CAAW,gBAAgB;QACtC;iCAAG;QAAC;QAAkB,QAAQ;KAAC;IAG/B,QAAI,mNAAA,EAAc,kBAAkB,MAAM,GAAG;QAC3C,UAAM,qNAAA,EAAgB,kBAAkB,UAAU,kBAAkB;IACtE;IAGA,QACE,2NAAA,EAAY;QACV;QACA;QACA,cAAc,iBAAiB,YAAA;QAC/B,OAAO,OACJ,aAAA,CAAc,EACd,GAAA,CAKC,iBAAiB,SAAS;QAC9B,UAAU,iBAAiB,QAAA;IAC7B,CAAC,GACD;QACA,MAAM,OAAO,KAAA;IACf;;iDAES,iBAAA,CAAkB,EAAE,OAAA,wKAAiB,wBAAA,mMAC5C,kBACA;IAGF,IACE,iBAAiB,6BAAA,IACjB,CAAC,0MAAA,QACD,+MAAA,EAAU,QAAQ,WAAW,GAC7B;YAGkE,kGAAA;;QAFlE,MAAM,UAAU,kBAAA,2GAAA;YAEZ,qNAAA,EAAgB,kBAAkB,UAAU,kBAAkB,IAAA,oCAEvD,aAAA,CAAc,EAAE,GAAA,CAAI,iBAAiB,SAAS,CAAG,8DAAxD,0BAAwD,OAAA;QAE5D,oBAAA,8BAAA,QAAS,KAAA,CAAM,sMAAI,EAAE,OAAA,CAAQ,MAAM;YAEjC,SAAS,YAAA,CAAa;QACxB,CAAC;IACH;IAGA,OAAO,CAAC,iBAAiB,mBAAA,GACrB,SAAS,WAAA,CAAY,MAAM,IAC3B;AACN","debugId":null}},
    {"offset": {"line": 870, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/react-query/src/useQuery.ts"],"sourcesContent":["'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  NoInfer,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery(options: UseQueryOptions, queryClient?: QueryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n"],"names":[],"mappings":";;;;;AACA,SAAS,qBAAqB;AAC9B,SAAS,oBAAoB;;;;AA+CtB,SAAS,SAAS,OAAA,EAA0B,WAAA,EAA2B;IAC5E,WAAO,sNAAA,EAAa,SAAS,uNAAA,EAAe,WAAW;AACzD","debugId":null}},
    {"offset": {"line": 889, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/react-query/src/useMutation.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  noop,\n  notifyManager,\n  shouldThrowError,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n"],"names":[],"mappings":";;;;;AACA,YAAY,WAAW;;;AACvB;AAMA,SAAS,sBAAsB;;;;;AAUxB,SAAS,YAMd,OAAA,EACA,WAAA,EACwD;IACxD,MAAM,aAAS,+NAAA,EAAe,WAAW;IAEzC,MAAM,CAAC,QAAQ,CAAA,GAAU,6LAAA;gCACvB,IACE,IAAI,6NAAA,CACF,QACA;;IAIA,8LAAA;iCAAU,MAAM;YACpB,SAAS,UAAA,CAAW,OAAO;QAC7B;gCAAG;QAAC;QAAU,OAAO;KAAC;IAEtB,MAAM,SAAe,yMAAA,CACb,gMAAA;oDACJ,CAAC,gBACC,SAAS,SAAA,CAAU,uNAAA,CAAc,UAAA,CAAW,aAAa,CAAC;mDAC5D;QAAC,QAAQ;KAAA;oDAEX,IAAM,SAAS,gBAAA,CAAiB;;oDAChC,IAAM,SAAS,gBAAA,CAAiB;;IAGlC,MAAM,SAAe,gMAAA;2CAGnB,CAAC,WAAW,kBAAkB;YAC5B,SAAS,MAAA,CAAO,WAAW,aAAa,EAAE,KAAA,CAAM,sMAAI;QACtD;0CACA;QAAC,QAAQ;KAAA;IAGX,IACE,OAAO,KAAA,QACP,kNAAA,EAAiB,SAAS,OAAA,CAAQ,YAAA,EAAc;QAAC,OAAO,KAAK;KAAC,GAC9D;QACA,MAAM,OAAO,KAAA;IACf;IAEA,OAAO;QAAE,GAAG,MAAA;QAAQ;QAAQ,aAAa,OAAO,MAAA;IAAO;AACzD","debugId":null}},
    {"offset": {"line": 949, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/showcase-next/node_modules/@tanstack/virtual-core/dist/esm/utils.js","sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/virtual-core/src/utils.ts"],"sourcesContent":["export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends ReadonlyArray<any>, TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => boolean\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n    skipInitialOnChange?: boolean\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n  let isInitial = true\n\n  function memoizedFunction(): TResult {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    if (opts?.onChange && !(isInitial && opts.skipInitialOnChange)) {\n      opts.onChange(result)\n    }\n\n    isInitial = false\n\n    return result\n  }\n\n  // Attach updateDeps to the function itself\n  memoizedFunction.updateDeps = (newDeps: [...TDeps]) => {\n    deps = newDeps\n  }\n\n  return memoizedFunction\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1.01\n\nexport const debounce = (\n  targetWindow: Window & typeof globalThis,\n  fn: Function,\n  ms: number,\n) => {\n  let timeoutId: number\n  return function (this: any, ...args: Array<any>) {\n    targetWindow.clearTimeout(timeoutId)\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAIO,SAAS,KACd,OAAA,EACA,EAAA,EACA,IAAA,EAOA;;IACA,IAAI,iCAAY,WAAA,6CAAL,oBAAoB,CAAA,CAAA;IAC/B,IAAI;IACJ,IAAI,YAAY;IAEhB,SAAS,mBAA4B;QAfhC,IAAA,IAAA,IAAA;QAgBH,IAAI;QACJ,IAAI,KAAK,GAAA,IAAA,CAAA,CAAO,KAAA,KAAK,KAAA,KAAL,OAAA,KAAA,IAAA,GAAA,IAAA,CAAA,KAAA,EAAgB,CAAA,UAAU,KAAK,GAAA,CAAA;QAE/C,MAAM,UAAU,QAAA;QAEhB,MAAM,cACJ,QAAQ,MAAA,KAAW,KAAK,MAAA,IACxB,QAAQ,IAAA,CAAK,CAAC,KAAU,QAAkB,IAAA,CAAK,KAAK,CAAA,KAAM,GAAG;QAE/D,IAAI,CAAC,aAAa;YAChB,OAAO;QACT;QAEA,OAAO;QAEP,IAAI;QACJ,IAAI,KAAK,GAAA,IAAA,CAAA,CAAO,KAAA,KAAK,KAAA,KAAL,OAAA,KAAA,IAAA,GAAA,IAAA,CAAA,KAAA,EAAgB,CAAA,aAAa,KAAK,GAAA,CAAA;QAElD,SAAS,GAAG,GAAG,OAAO;QAEtB,IAAI,KAAK,GAAA,IAAA,CAAA,CAAO,KAAA,KAAK,KAAA,KAAL,OAAA,KAAA,IAAA,GAAA,IAAA,CAAA,KAAA,GAAgB;YAC9B,MAAM,aAAa,KAAK,KAAA,CAAA,CAAO,KAAK,GAAA,KAAQ,OAAA,IAAY,GAAG,IAAI;YAC/D,MAAM,gBAAgB,KAAK,KAAA,CAAA,CAAO,KAAK,GAAA,KAAQ,UAAA,IAAe,GAAG,IAAI;YACrE,MAAM,sBAAsB,gBAAgB;YAE5C,MAAM,MAAM,CAAC,KAAsB,QAAgB;gBACjD,MAAM,OAAO,GAAG;gBAChB,MAAO,IAAI,MAAA,GAAS,IAAK;oBACvB,MAAM,MAAM;gBACd;gBACA,OAAO;YACT;YAEA,QAAQ,IAAA,CACN,OAAiC,OAA1B,IAAI,eAAe,CAAC,CAAC,EAAA,MAAuB,WAAd,YAAY,CAAC,CAAC,EAAA,QACnD,2FAMK,OAHY,KAAK,GAAA,CAChB,GACA,KAAK,GAAA,CAAI,MAAM,MAAM,qBAAqB,GAAG,IAC9C,mBACL,QAAA,OAAA,KAAA,IAAA,KAAM,GAAA;QAEV;QAEA,IAAA,CAAI,QAAA,OAAA,KAAA,IAAA,KAAM,QAAA,KAAY,CAAA,CAAE,aAAa,KAAK,mBAAA,GAAsB;YAC9D,KAAK,QAAA,CAAS,MAAM;QACtB;QAEA,YAAY;QAEZ,OAAO;IACT;IAGA,iBAAiB,UAAA,GAAa,CAAC,YAAwB;QACrD,OAAO;IACT;IAEA,OAAO;AACT;AAEO,SAAS,aAAgB,KAAA,EAAsB,GAAA,EAAiB;IACrE,IAAI,UAAU,KAAA,GAAW;QACvB,MAAM,IAAI,MAAM,uBAA4C,CAAE,MAAvB,MAAM,KAAQ,OAAH,GAAG,IAAK,EAAE;IAC9D,OAAO;QACL,OAAO;IACT;AACF;AAEO,MAAM,cAAc,CAAC,GAAW,IAAc,KAAK,GAAA,CAAI,IAAI,CAAC,IAAI;AAEhE,MAAM,WAAW,CACtB,cACA,IACA,OACG;IACH,IAAI;IACJ,OAAO;QAAA,IAAA,IAAA,OAAA,UAAA,QAAA,OAAA,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;YAAwB,KAAxB,QAAA,SAAA,CAAA,KAAwB,EAAkB;;QAC/C,aAAa,YAAA,CAAa,SAAS;QACnC,YAAY,aAAa,UAAA,CAAW,IAAM,GAAG,KAAA,CAAM,IAAA,EAAM,IAAI,GAAG,EAAE;IACpE;AACF","debugId":null}},
    {"offset": {"line": 1025, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/showcase-next/node_modules/@tanstack/virtual-core/dist/esm/index.js","sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/virtual-core/src/index.ts"],"sourcesContent":["import { approxEqual, debounce, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string | bigint\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n}\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\n//\n\nconst getRect = (element: HTMLElement): Rect => {\n  const { offsetWidth, offsetHeight } = element\n  return { width: offsetWidth, height: offsetHeight }\n}\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(getRect(element as unknown as HTMLElement))\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {}\n  }\n\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0]\n      if (entry?.borderBoxSize) {\n        const box = entry.borderBoxSize[0]\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize })\n          return\n        }\n      }\n      handler(getRect(element as unknown as HTMLElement))\n    }\n\n    instance.options.useAnimationFrameWithResizeObserver\n      ? requestAnimationFrame(run)\n      : run()\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nconst addEventListenerOptions = {\n  passive: true,\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nconst supportsScrollend =\n  typeof window == 'undefined' ? true : 'onscrollend' in window\n\ntype ObserveOffsetCallBack = (offset: number, isScrolling: boolean) => void\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    const { horizontal, isRtl } = instance.options\n    offset = horizontal\n      ? element['scrollLeft'] * ((isRtl && -1) || 1)\n      : element['scrollTop']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollX' : 'scrollY']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n\n  return (element as unknown as HTMLElement)[\n    instance.options.horizontal ? 'offsetWidth' : 'offsetHeight'\n  ]\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: ObserveOffsetCallBack,\n  ) => void | (() => void)\n  // Optional\n  debug?: boolean\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number | (() => number)\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => Array<number>\n  scrollMargin?: number\n  gap?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: Array<VirtualItem>\n  lanes?: number\n  isScrollingResetDelay?: number\n  useScrollendEvent?: boolean\n  enabled?: boolean\n  isRtl?: boolean\n  useAnimationFrameWithResizeObserver?: boolean\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: Array<void | (() => void)> = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  targetWindow: (Window & typeof globalThis) | null = null\n  isScrolling = false\n  private currentScrollToIndex: number | null = null\n  measurementsCache: Array<VirtualItem> = []\n  private itemSizeCache = new Map<Key, number>()\n  private laneAssignments = new Map<number, number>() // index  lane cache\n  private pendingMeasuredCacheIndexes: Array<number> = []\n  private prevLanes: number | undefined = undefined\n  private lanesChangedFlag = false\n  private lanesSettling = false\n  scrollRect: Rect | null = null\n  scrollOffset: number | null = null\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments = 0\n  shouldAdjustScrollPositionOnItemSizeChange:\n    | undefined\n    | ((\n        item: VirtualItem,\n        delta: number,\n        instance: Virtualizer<TScrollElement, TItemElement>,\n      ) => boolean)\n  elementsCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      }\n\n      if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n        return null\n      }\n\n      return (_ro = new this.targetWindow.ResizeObserver((entries) => {\n        entries.forEach((entry) => {\n          const run = () => {\n            this._measureElement(entry.target as TItemElement, entry)\n          }\n          this.options.useAnimationFrameWithResizeObserver\n            ? requestAnimationFrame(run)\n            : run()\n        })\n      }))\n    }\n\n    return {\n      disconnect: () => {\n        get()?.disconnect()\n        _ro = null\n      },\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      isRtl: false,\n      useScrollendEvent: false,\n      useAnimationFrameWithResizeObserver: false,\n      ...opts,\n    }\n  }\n\n  private notify = (sync: boolean) => {\n    this.options.onChange?.(this, sync)\n  }\n\n  private maybeNotify = memo(\n    () => {\n      this.calculateRange()\n\n      return [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ]\n    },\n    (isScrolling) => {\n      this.notify(isScrolling)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'maybeNotify',\n      debug: () => this.options.debug,\n      initialDeps: [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ] as [boolean, number | null, number | null],\n    },\n  )\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.observer.disconnect()\n    this.scrollElement = null\n    this.targetWindow = null\n  }\n\n  _didMount = () => {\n    return () => {\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.enabled\n      ? this.options.getScrollElement()\n      : null\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      if (!scrollElement) {\n        this.maybeNotify()\n        return\n      }\n\n      this.scrollElement = scrollElement\n\n      if (this.scrollElement && 'ownerDocument' in this.scrollElement) {\n        this.targetWindow = this.scrollElement.ownerDocument.defaultView\n      } else {\n        this.targetWindow = this.scrollElement?.window ?? null\n      }\n\n      this.elementsCache.forEach((cached) => {\n        this.observer.observe(cached)\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.maybeNotify()\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0\n          this.scrollDirection = isScrolling\n            ? this.getScrollOffset() < offset\n              ? 'forward'\n              : 'backward'\n            : null\n          this.scrollOffset = offset\n          this.isScrolling = isScrolling\n\n          this.maybeNotify()\n        }),\n      )\n\n      this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n    }\n  }\n\n  private getSize = () => {\n    if (!this.options.enabled) {\n      this.scrollRect = null\n      return 0\n    }\n\n    this.scrollRect = this.scrollRect ?? this.options.initialRect\n\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getScrollOffset = () => {\n    if (!this.options.enabled) {\n      this.scrollOffset = null\n      return 0\n    }\n\n    this.scrollOffset =\n      this.scrollOffset ??\n      (typeof this.options.initialOffset === 'function'\n        ? this.options.initialOffset()\n        : this.options.initialOffset)\n\n    return this.scrollOffset\n  }\n\n  private getFurthestMeasurement = (\n    measurements: Array<VirtualItem>,\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n          if (a.end === b.end) {\n            return a.index - b.index\n          }\n\n          return a.end - b.end\n        })[0]\n      : undefined\n  }\n\n  private getMeasurementOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.options.enabled,\n      this.options.lanes,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, enabled, lanes) => {\n      const lanesChanged =\n        this.prevLanes !== undefined && this.prevLanes !== lanes\n\n      if (lanesChanged) {\n        // Set flag for getMeasurements to handle\n        this.lanesChangedFlag = true\n      }\n\n      this.prevLanes = lanes\n      this.pendingMeasuredCacheIndexes = []\n\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled,\n        lanes,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getMeasurements = memo(\n    () => [this.getMeasurementOptions(), this.itemSizeCache],\n    (\n      { count, paddingStart, scrollMargin, getItemKey, enabled, lanes },\n      itemSizeCache,\n    ) => {\n      if (!enabled) {\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        this.laneAssignments.clear()\n        return []\n      }\n\n      // Clean up stale lane cache entries when count decreases\n      if (this.laneAssignments.size > count) {\n        for (const index of this.laneAssignments.keys()) {\n          if (index >= count) {\n            this.laneAssignments.delete(index)\n          }\n        }\n      }\n\n      //  Force complete recalculation when lanes change\n      if (this.lanesChangedFlag) {\n        this.lanesChangedFlag = false // Reset immediately\n        this.lanesSettling = true // Start settling period\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        this.laneAssignments.clear() // Clear lane cache for new lane count\n        // Clear pending indexes to force min = 0\n        this.pendingMeasuredCacheIndexes = []\n      }\n\n      // Don't restore from initialMeasurementsCache during lane changes\n      // as it contains stale lane assignments from the previous lane count\n      if (this.measurementsCache.length === 0 && !this.lanesSettling) {\n        this.measurementsCache = this.options.initialMeasurementsCache\n        this.measurementsCache.forEach((item) => {\n          this.itemSizeCache.set(item.key, item.size)\n        })\n      }\n\n      //  During lanes settling, ignore pendingMeasuredCacheIndexes to prevent repositioning\n      const min = this.lanesSettling\n        ? 0\n        : this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      //  End settling period when cache is fully built\n      if (this.lanesSettling && this.measurementsCache.length === count) {\n        this.lanesSettling = false\n      }\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      //  Performance: Track last item index per lane for O(1) lookup\n      const laneLastIndex: Array<number | undefined> = new Array(lanes).fill(\n        undefined,\n      )\n\n      // Initialize from existing measurements (before min)\n      for (let m = 0; m < min; m++) {\n        const item = measurements[m]\n        if (item) {\n          laneLastIndex[item.lane] = m\n        }\n      }\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n\n        // Check for cached lane assignment\n        const cachedLane = this.laneAssignments.get(i)\n        let lane: number\n        let start: number\n\n        if (cachedLane !== undefined && this.options.lanes > 1) {\n          // Use cached lane - O(1) lookup for previous item in same lane\n          lane = cachedLane\n          const prevIndex = laneLastIndex[lane]\n          const prevInLane =\n            prevIndex !== undefined ? measurements[prevIndex] : undefined\n          start = prevInLane\n            ? prevInLane.end + this.options.gap\n            : paddingStart + scrollMargin\n        } else {\n          // No cache - use original logic (find shortest lane)\n          const furthestMeasurement =\n            this.options.lanes === 1\n              ? measurements[i - 1]\n              : this.getFurthestMeasurement(measurements, i)\n\n          start = furthestMeasurement\n            ? furthestMeasurement.end + this.options.gap\n            : paddingStart + scrollMargin\n\n          lane = furthestMeasurement\n            ? furthestMeasurement.lane\n            : i % this.options.lanes\n\n          // Cache the lane assignment\n          if (this.options.lanes > 1) {\n            this.laneAssignments.set(i, lane)\n          }\n        }\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n        }\n\n        //  Performance: Update lane's last item index\n        laneLastIndex[lane] = i\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [\n      this.getMeasurements(),\n      this.getSize(),\n      this.getScrollOffset(),\n      this.options.lanes,\n    ],\n    (measurements, outerSize, scrollOffset, lanes) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n              lanes,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualIndexes = memo(\n    () => {\n      let startIndex: number | null = null\n      let endIndex: number | null = null\n      const range = this.calculateRange()\n      if (range) {\n        startIndex = range.startIndex\n        endIndex = range.endIndex\n      }\n      this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex])\n      return [\n        this.options.rangeExtractor,\n        this.options.overscan,\n        this.options.count,\n        startIndex,\n        endIndex,\n      ]\n    },\n    (rangeExtractor, overscan, count, startIndex, endIndex) => {\n      return startIndex === null || endIndex === null\n        ? []\n        : rangeExtractor({\n            startIndex,\n            endIndex,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const index = this.indexFromElement(node)\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const key = item.key\n    const prevNode = this.elementsCache.get(key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.elementsCache.set(key, node)\n    }\n\n    if (node.isConnected) {\n      this.resizeItem(index, this.options.measureElement(node, entry, this))\n    }\n  }\n\n  resizeItem = (index: number, size: number) => {\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (\n        this.shouldAdjustScrollPositionOnItemSizeChange !== undefined\n          ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this)\n          : item.start < this.getScrollOffset() + this.scrollAdjustments\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null | undefined) => {\n    if (!node) {\n      this.elementsCache.forEach((cached, key) => {\n        if (!cached.isConnected) {\n          this.observer.unobserve(cached)\n          this.elementsCache.delete(key)\n        }\n      })\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getVirtualIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: Array<VirtualItem> = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualItems',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n    if (measurements.length === 0) {\n      return undefined\n    }\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  private getMaxScrollOffset = () => {\n    if (!this.scrollElement) return 0\n\n    if ('scrollHeight' in this.scrollElement) {\n      // Element\n      return this.options.horizontal\n        ? this.scrollElement.scrollWidth - this.scrollElement.clientWidth\n        : this.scrollElement.scrollHeight - this.scrollElement.clientHeight\n    } else {\n      // Window\n      const doc = this.scrollElement.document.documentElement\n      return this.options.horizontal\n        ? doc.scrollWidth - this.scrollElement.innerWidth\n        : doc.scrollHeight - this.scrollElement.innerHeight\n    }\n  }\n\n  getOffsetForAlignment = (\n    toOffset: number,\n    align: ScrollAlignment,\n    itemSize = 0,\n  ) => {\n    if (!this.scrollElement) return 0\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      align = toOffset >= scrollOffset + size ? 'end' : 'start'\n    }\n\n    if (align === 'center') {\n      // When aligning to a particular item (e.g. with scrollToIndex),\n      // adjust offset by the size of the item to center on the item\n      toOffset += (itemSize - size) / 2\n    } else if (align === 'end') {\n      toOffset -= size\n    }\n\n    const maxOffset = this.getMaxScrollOffset()\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return undefined\n    }\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n        align = 'start'\n      } else {\n        return [scrollOffset, align] as const\n      }\n    }\n\n    // For the last item with 'end' alignment, use browser's actual max scroll\n    // to account for borders/padding that aren't in our measurements\n    if (align === 'end' && index === this.options.count - 1) {\n      return [this.getMaxScrollOffset(), align] as const\n    }\n\n    const toOffset =\n      align === 'end'\n        ? item.end + this.options.scrollPaddingEnd\n        : item.start - this.options.scrollPaddingStart\n\n    return [\n      this.getOffsetForAlignment(toOffset, align, item.size),\n      align,\n    ] as const\n  }\n\n  private isDynamicMode = () => this.elementsCache.size > 0\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n    this.currentScrollToIndex = index\n\n    let attempts = 0\n    const maxAttempts = 10\n\n    const tryScroll = (currentAlign: ScrollAlignment) => {\n      if (!this.targetWindow) return\n\n      const offsetInfo = this.getOffsetForIndex(index, currentAlign)\n      if (!offsetInfo) {\n        console.warn('Failed to get offset for index:', index)\n        return\n      }\n      const [offset, align] = offsetInfo\n      this._scrollToOffset(offset, { adjustments: undefined, behavior })\n\n      this.targetWindow.requestAnimationFrame(() => {\n        const verify = () => {\n          // Abort if a new scrollToIndex was called with a different index\n          if (this.currentScrollToIndex !== index) return\n\n          const currentOffset = this.getScrollOffset()\n          const afterInfo = this.getOffsetForIndex(index, align)\n          if (!afterInfo) {\n            console.warn('Failed to get offset for index:', index)\n            return\n          }\n\n          if (!approxEqual(afterInfo[0], currentOffset)) {\n            scheduleRetry(align)\n          }\n        }\n\n        // In dynamic mode, wait an extra frame for ResizeObserver to measure newly visible elements\n        if (this.isDynamicMode()) {\n          this.targetWindow!.requestAnimationFrame(verify)\n        } else {\n          verify()\n        }\n      })\n    }\n\n    const scheduleRetry = (align: ScrollAlignment) => {\n      if (!this.targetWindow) return\n\n      // Abort if a new scrollToIndex was called with a different index\n      if (this.currentScrollToIndex !== index) return\n\n      attempts++\n      if (attempts < maxAttempts) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('Schedule retry', attempts, maxAttempts)\n        }\n        this.targetWindow.requestAnimationFrame(() => tryScroll(align))\n      } else {\n        console.warn(\n          `Failed to scroll to index ${index} after ${maxAttempts} attempts.`,\n        )\n      }\n    }\n\n    tryScroll(initialAlign)\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getScrollOffset() + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () => {\n    const measurements = this.getMeasurements()\n\n    let end: number\n    // If there are no measurements, set the end to paddingStart\n    // If there is only one lane, use the last measurement's end\n    // Otherwise find the maximum end value among all measurements\n    if (measurements.length === 0) {\n      end = this.options.paddingStart\n    } else if (this.options.lanes === 1) {\n      end = measurements[measurements.length - 1]?.end ?? 0\n    } else {\n      const endByLane = Array<number | null>(this.options.lanes).fill(null)\n      let endIndex = measurements.length - 1\n      while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n        const item = measurements[endIndex]!\n        if (endByLane[item.lane] === null) {\n          endByLane[item.lane] = item.end\n        }\n\n        endIndex--\n      }\n\n      end = Math.max(...endByLane.filter((val): val is number => val !== null))\n    }\n\n    return Math.max(\n      end - this.options.scrollMargin + this.options.paddingEnd,\n      0,\n    )\n  }\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.laneAssignments = new Map() // Clear lane cache for full re-layout\n    this.notify(false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes,\n}: {\n  measurements: Array<VirtualItem>\n  outerSize: number\n  scrollOffset: number\n  lanes: number\n}) {\n  const lastIndex = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  // handle case when item count is less than or equal to lanes\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex,\n    }\n  }\n\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset,\n  )\n  let endIndex = startIndex\n\n  if (lanes === 1) {\n    while (\n      endIndex < lastIndex &&\n      measurements[endIndex]!.end < scrollOffset + outerSize\n    ) {\n      endIndex++\n    }\n  } else if (lanes > 1) {\n    // Expand forward until we include the visible items from all lanes\n    // which are closer to the end of the virtualizer window\n    const endPerLane = Array(lanes).fill(0)\n    while (\n      endIndex < lastIndex &&\n      endPerLane.some((pos) => pos < scrollOffset + outerSize)\n    ) {\n      const item = measurements[endIndex]!\n      endPerLane[item.lane] = item.end\n      endIndex++\n    }\n\n    // Expand backward until we include all lanes' visible items\n    // closer to the top\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize)\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex]!\n      startPerLane[item.lane] = item.start\n      startIndex--\n    }\n\n    // Align startIndex to the beginning of its lane\n    startIndex = Math.max(0, startIndex - (startIndex % lanes))\n    // Align endIndex to the end of its lane\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - (endIndex % lanes)))\n  }\n\n  return { startIndex, endIndex }\n}\n"],"names":["opts"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1903, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/showcase-next/node_modules/@tanstack/react-virtual/dist/esm/index.js","sources":["file:///C:/Users/james/showcase-redo/showcase-next/node_modules/%40tanstack/react-virtual/src/index.tsx"],"sourcesContent":["import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport {\n  Virtualizer,\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll,\n} from '@tanstack/virtual-core'\nimport type { PartialKeys, VirtualizerOptions } from '@tanstack/virtual-core'\n\nexport * from '@tanstack/virtual-core'\n\nconst useIsomorphicLayoutEffect =\n  typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nexport type ReactVirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> = VirtualizerOptions<TScrollElement, TItemElement> & {\n  useFlushSync?: boolean\n}\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>({\n  useFlushSync = true,\n  ...options\n}: ReactVirtualizerOptions<TScrollElement, TItemElement>): Virtualizer<\n  TScrollElement,\n  TItemElement\n> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance, sync) => {\n      if (useFlushSync && sync) {\n        flushSync(rerender)\n      } else {\n        rerender()\n      }\n      options.onChange?.(instance, sync)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: PartialKeys<\n    ReactVirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: PartialKeys<\n    ReactVirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof document !== 'undefined' ? window : null),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: () => (typeof document !== 'undefined' ? window.scrollY : 0),\n    ...options,\n  })\n}\n"],"names":["instance"],"mappings":";;;;;;;;;;;;;AAeA,MAAM,4BACJ,OAAO,aAAa,cAAc,MAAM,8LAAA,GAAkB,MAAM,wLAAA;AASlE,SAAS,wBAMT;UAFE,eAAe,IAAA,EACf,GAAG,SACL,EAGE,CANA;IAOA,MAAM,WAAW,MAAM,yLAAA;yCAAW,IAAA,CAAO,CAAA,CAAA;wCAAK,CAAA,CAAE,CAAA,CAAE,CAAC,CAAA;IAEnD,MAAM,kBAAoE;QACxE,GAAG,OAAA;QACH,UAAU,CAACA,WAAU,SAAS;;YAC5B,IAAI,gBAAgB,MAAM;gBACxB,IAAA,qMAAA,EAAU,QAAQ;YACpB,OAAO;gBACL,SAAA;YACF;YACA,CAAA,KAAA,QAAQ,QAAA,KAAR,OAAA,KAAA,IAAA,GAAA,IAAA,CAAA,SAAmBA,WAAU;QAC/B;IAAA;IAGF,MAAM,CAAC,QAAQ,CAAA,GAAI,MAAM,uLAAA;uCACvB,IAAM,IAAI,2NAAA,CAA0C,eAAe;;IAGrE,SAAS,UAAA,CAAW,eAAe;IAEnC;wDAA0B,MAAM;YAC9B,OAAO,SAAS,SAAA,CAAA;QAClB;uDAAG,CAAA,CAAE;IAEL;wDAA0B,MAAM;YAC9B,OAAO,SAAS,WAAA,CAAA;QAClB,CAAC;;IAED,OAAO;AACT;AAEO,SAAS,eAId,OAAA,EAI2C;IAC3C,OAAO,mBAAiD;4BACtD,kOAAA;8BACA,oOAAA;QACA,YAAY,6NAAA;QACZ,GAAG,OAAA;IAAA,CACJ;AACH;AAEO,SAAS,qBACd,OAAA,EAOmC;IACnC,OAAO,mBAAyC;QAC9C,gBAAA;uDAAkB,IAAO,OAAO,aAAa,cAAc,SAAS;;QACpE,oBAAoB,iOAAA;QACpB,sBAAsB,mOAAA;QACtB,YAAY,4NAAA;QACZ,aAAA;uDAAe,IAAO,OAAO,aAAa,cAAc,OAAO,OAAA,GAAU;;QACzE,GAAG,OAAA;IAAA,CACJ;AACH","debugId":null}}]
}